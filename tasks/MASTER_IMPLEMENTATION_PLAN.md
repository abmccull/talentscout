# TalentScout — Master Implementation Plan
## 20 Systems for Game Depth, Replayability & Quality

> **Governing Document** — All agent swarms reference this as their single source of truth.
> Each feature has its own section with architecture, file changes, type additions, and a
> checklist. Agents mark items `[x]` as they complete them and note blockers inline.

---

## Architecture Standards (ALL AGENTS MUST FOLLOW)

1. **Pure engine functions** — No React imports in `src/engine/**`. All functions are pure (input → output, no side effects).
2. **Types in `types.ts`** — All new interfaces/types go in `src/engine/core/types.ts`. No ad-hoc type files.
3. **Immutable state** — Never mutate inputs. Always return new objects via spread.
4. **RNG threading** — All randomness flows through the `RNG` instance. Never use `Math.random()`.
5. **ID generation** — Use `generateId(prefix)` from `gameLoop.ts` for all new entity IDs.
6. **Barrel exports** — Each engine subdirectory has an `index.ts` that re-exports its public API.
7. **Migration** — Any new fields on `GameState` or `Player` must have migration logic in `gameStore.ts` (in `migrateMatchRatings` or a new migration function) with `??=` defaulting.
8. **Store integration** — Engine logic returns new state; `gameStore.ts` actions apply it. Keep store actions thin.
9. **1-20 scale** for player attributes, **1-200 scale** for ability, **1-10 scale** for match ratings, **[-3,3]** for form.
10. **Build check** — Every phase must end with `npm run build` passing with zero new errors.

---

## Feature Dependency Graph

```
Independent (can run in parallel):
  F1  Season Events Overhaul
  F6  Discipline/Card System
  F7  Injury System Overhaul
  F9  Player Personality System
  F11 Scouting Report Comparison
  F13 Regional Scouting Depth
  F14 Financial Strategy Layer
  F15 Match Commentary Enhancement
  F16 Calendar Week Preview
  F17 Quick Scout Mode
  F18 Achievement System
  F20 Data Visualization Dashboard

Depends on F1 (Season Events):
  F2  Narrative Event Chains (needs event infrastructure from F1)

Depends on F6 (Cards) and F7 (Injuries):
  F8  Rival Scouts Enhancement (needs cards/injuries for richer match context)

Depends on F9 (Personality):
  F4  Transfer Negotiation (uses personality in negotiation behavior)

Depends on F2 (Event Chains):
  F3  Contact Network Depth (uses event chain system for gossip/betrayal arcs)
  F10 Dynamic Board Expectations (uses event chains for board pressure arcs)

Depends on F6 + F7 + F9:
  F5  Match Tactical Layer (needs cards, injuries, personality for full tactical sim)

Depends on F18 (Achievements):
  F19 New Game+ / Legacy Mode (uses achievement data for unlocks)

Depends on F7 + F12:
  F12 Youth Pipeline Tracking (needs injury system for realistic youth career tracking)
```

### Deployment Waves

| Wave | Features | Dependencies |
|------|----------|-------------|
| **Wave 1** (parallel) | F1, F6, F7, F9, F11, F13, F14, F15, F16, F17, F18, F20 | None |
| **Wave 2** (parallel) | F2, F4, F8, F12 | Wave 1 complete |
| **Wave 3** (parallel) | F3, F5, F10, F19 | Wave 2 complete |

---

## F1: Season Events Overhaul

### Goal
Transform the 8 skeletal season events from flavor text into mechanically impactful gameplay moments. Each event type should change game state, open/close opportunities, and create decision points.

### Current State
- `src/engine/core/seasonEvents.ts` (202 lines) — 8 fixed event types, purely informational
- Events generated by `generateSeasonEvents(season)`, queried by `getActiveSeasonEvents()`
- No mechanical effects — events don't modify GameState
- `SeasonEvent` type in `types.ts` (~line 1135) has `type`, `name`, `startWeek`, `endWeek`, `description`

### Architecture

**Extend `SeasonEvent` type** in `types.ts`:
```typescript
interface SeasonEvent {
  // existing fields...
  effects?: SeasonEventEffect[];
  choices?: SeasonEventChoice[];
  resolved?: boolean;
}

interface SeasonEventEffect {
  type: "transferPriceModifier" | "scoutingCostModifier" | "fatigueModifier" |
        "reputationBonus" | "youthIntake" | "playerAvailability" | "injuryRiskModifier";
  value: number;
  targetScope?: "global" | "league" | "club";
  targetId?: string;
}

interface SeasonEventChoice {
  label: string;
  description: string;
  effects: SeasonEventEffect[];
}
```

**New file: `src/engine/core/seasonEventEffects.ts`** (~200 lines)
- `applySeasonEventEffects(state, activeEvents, rng)` — called in `processWeeklyTick`
- `resolveSeasonEventChoice(state, eventId, choiceIndex)` — player-initiated resolution
- Effect handlers per type (transfer price mods, scouting cost mods, etc.)

**Modify `seasonEvents.ts`**:
- Each event template gains `effects` and optional `choices`
- `transferDeadlineDay`: panic pricing (+30% transfer fees last 3 days), rival scout urgency, exclusive tips from contacts
- `internationalBreak`: players unavailable for club matches, international tournament scouting opportunities (+20% attribute reveal for international players), reduced fatigue recovery
- `preSeasonTournament`: cheaper scouting trips (-40% travel cost), more matches to attend, attribute reveal bonus for youth players
- `winterTransferWindow`: mid-season transfers, loan recalls, desperation deals (-15% price for relegation clubs)
- `youthCup`: batch youth prospect visibility (+50% youth venue quality), youth-spec scouts get bonus observations
- `endOfSeasonReview`: board evaluation, contract decisions, award ceremonies affecting reputation

**Modify `gameLoop.ts`** (`processWeeklyTick`):
- After fixture simulation, call `applySeasonEventEffects(state, activeEvents, rng)`
- Pass active season events to `simulateFixture` for injury risk / fatigue modifiers
- Check for unresolved choices and queue inbox messages

**Modify `gameStore.ts`**:
- Add `resolveSeasonEvent(eventId, choiceIndex)` action
- Migrate: `state.seasonEvents` entries gain `effects`, `choices`, `resolved` fields

**UI: `SeasonTimeline.tsx`** (159 lines):
- Show active effects as badges on timeline
- Add choice modal for events with `choices`
- Color-code events by impact type

### Checklist
- [x] Extend `SeasonEvent` type with `effects`, `choices`, `resolved` in `types.ts`
- [x] Add `SeasonEventEffect` and `SeasonEventChoice` types
- [x] Create `src/engine/core/seasonEventEffects.ts` with effect application logic
- [x] Update all 8 event templates in `seasonEvents.ts` with mechanical effects
- [x] Add `transferDeadlineDay` panic pricing mechanics
- [x] Add `internationalBreak` player availability and scouting bonuses
- [x] Add `preSeasonTournament` travel cost reduction and reveal bonuses
- [x] Add `winterTransferWindow` mid-season transfer mechanics
- [x] Add `youthCup` youth prospect visibility bonuses
- [x] Add `endOfSeasonReview` board evaluation and reputation effects
- [x] Wire `applySeasonEventEffects` into `processWeeklyTick` in `gameLoop.ts`
- [x] Add `resolveSeasonEvent` action to `gameStore.ts`
- [x] Add migration for new SeasonEvent fields
- [x] Update `SeasonTimeline.tsx` with effect badges and choice modals
- [x] `npm run build` passes (`npx tsc --noEmit` zero errors; SSR prerender failure is pre-existing infrastructure issue)

---

## F2: Narrative Event Chains

### Goal
Events currently fire independently with no memory. Transform them into multi-week storylines where events reference prior events, escalate if unresolved, and create emergent narratives.

### Current State
- `src/engine/events/narrativeEvents.ts` (1,001 lines) — 12% weekly chance, 2-week cooldown
- `src/engine/events/eventTemplates.ts` (1,410 lines) — 25+ event types, each with 2-3 choices
- `src/engine/events/storylines.ts` (1,090 lines) — narrative arc definitions (partially implemented)
- `NarrativeEvent` type has `type`, `choices`, `outcome`, `acknowledged`
- Events are independent — no `chainId`, no follow-up triggers, no escalation

### Architecture

**Extend `NarrativeEvent` type** in `types.ts`:
```typescript
interface NarrativeEvent {
  // existing fields...
  chainId?: string;             // links events in same storyline
  chainStep?: number;           // 1, 2, 3... position in chain
  parentEventId?: string;       // which event triggered this one
  followUpWeek?: number;        // when the follow-up fires (absolute week)
  escalationLevel?: number;     // 0=normal, 1=warning, 2=critical
  resolved?: boolean;           // was this chain concluded?
}
```

**Add `EventChain` type**:
```typescript
interface EventChain {
  id: string;
  templateKey: string;          // which chain template
  startWeek: number;
  currentStep: number;
  maxSteps: number;
  resolved: boolean;
  choiceHistory: number[];      // choices made at each step
  context: Record<string, string>; // carried data (playerId, clubId, etc.)
}
```

**Add to `GameState`**: `eventChains: EventChain[]`

**New file: `src/engine/events/eventChains.ts`** (~400 lines)
- `CHAIN_TEMPLATES` — 10-15 multi-step chain definitions:
  - `dressingRoomConflict` (3 steps: rumor → confrontation → resolution/departure)
  - `transferSaga` (4 steps: rumor → interest → bid → resolution)
  - `wonderkidPressure` (3 steps: media attention → performance pressure → breakthrough/burnout)
  - `boardUltimatum` (3 steps: warning → deadline → consequence)
  - `rivalPoaching` (3 steps: scout spotted → offer made → counter/lose)
  - `injuryComeback` (3 steps: injury → rehab updates → return/setback)
  - `contactBetrayal` (2 steps: suspicious behavior → betrayal/loyalty)
  - `scoutingScandal` (3 steps: accusation → investigation → vindication/fallout)
  - `managerFallout` (3 steps: disagreement → tension → firing/reconciliation)
  - `youthBreakthrough` (3 steps: promise → breakthrough match → star/fade)
- `startChain(rng, state, templateKey)` → creates EventChain + first NarrativeEvent
- `advanceChain(rng, state, chainId, choiceIndex)` → generates next step based on prior choices
- `checkPendingChains(state, currentWeek)` → returns chains due for next event
- `resolveChain(state, chainId, outcome)` → marks chain complete, applies final effects

**Modify `narrativeEvents.ts`**:
- `generateWeeklyEvent` checks `checkPendingChains` first — chain continuations take priority over random events
- Chain events bypass the 12% roll (they fire deterministically when scheduled)
- Random events can now trigger `startChain` for eligible templates (10% chance an event becomes a chain)

**Modify `gameStore.ts`**:
- Add `resolveNarrativeEventChoice` to check if event is part of a chain and call `advanceChain`
- Add migration: `state.eventChains ??= []`

**UI: `InboxScreen.tsx`** (564 lines):
- Chain events show a "Part X of Y" indicator
- Escalated events show warning/critical badge
- Previous chain choices shown as context when viewing continuation events

### Checklist
- [ ] Extend `NarrativeEvent` with `chainId`, `chainStep`, `parentEventId`, `followUpWeek`, `escalationLevel`, `resolved`
- [ ] Add `EventChain` type to `types.ts`
- [ ] Add `eventChains: EventChain[]` to `GameState`
- [ ] Create `src/engine/events/eventChains.ts` with chain templates and logic
- [ ] Implement `dressingRoomConflict` chain (3 steps)
- [ ] Implement `transferSaga` chain (4 steps)
- [ ] Implement `wonderkidPressure` chain (3 steps)
- [ ] Implement `boardUltimatum` chain (3 steps)
- [ ] Implement `rivalPoaching` chain (3 steps)
- [ ] Implement at least 5 more chain templates
- [ ] Modify `generateWeeklyEvent` to prioritize chain continuations
- [ ] Add 10% chain trigger chance to random events
- [ ] Update `resolveNarrativeEventChoice` in `gameStore.ts` for chain advancement
- [ ] Add migration for `eventChains`
- [ ] Update `InboxScreen.tsx` with chain indicators
- [ ] `npm run build` passes

---

## F3: Contact Network Depth

### Goal
Transform contacts from static bonus providers into dynamic relationships with trust, gossip, betrayal, and referral mechanics.

### Current State
- `src/engine/network/contacts.ts` (799 lines) — contact types, tips, meetings
- `Contact` type has `type`, `trust`, `tips`, `relationship`
- 4 contact types: clubInsider, agent, journalist, scout
- Contacts provide intel bonuses but don't evolve meaningfully

### Architecture

**Extend `Contact` type** in `types.ts`:
```typescript
interface Contact {
  // existing fields...
  trustLevel: number;           // 0-100 (replaces or extends trust)
  loyalty: number;              // 0-100 hidden stat
  lastInteractionWeek: number;
  interactionHistory: ContactInteraction[];
  gossipQueue: GossipItem[];    // pending gossip to reveal
  referralNetwork: string[];    // IDs of contacts they can introduce
  betrayalRisk: number;         // 0-1 probability
  exclusiveWindow?: {           // timed exclusive on a prospect
    playerId: string;
    expiresWeek: number;
  };
}

interface ContactInteraction {
  week: number;
  type: "meeting" | "tip" | "referral" | "betrayal" | "favor";
  trustDelta: number;
}

interface GossipItem {
  id: string;
  type: "transferRumor" | "unhappyPlayer" | "youthProspect" | "managerChange" | "injuryNews";
  playerId?: string;
  clubId?: string;
  reliability: number;          // 0-1 (contact loyalty affects this)
  revealedWeek: number;
  expiresWeek: number;          // gossip becomes stale
  content: string;
}
```

**New file: `src/engine/network/gossip.ts`** (~300 lines)
- `generateGossip(rng, contact, state)` — creates gossip items based on contact type and trust
- `processGossipDecay(state)` — removes expired gossip, reduces trust for old contacts
- `evaluateGossipAccuracy(gossipItem, state)` — was the gossip true? Affects trust

**New file: `src/engine/network/referrals.ts`** (~200 lines)
- `generateReferralOpportunity(rng, contact, state)` — high-trust contacts offer introductions
- `processReferral(state, contactId, referredContactId)` — creates new contact from referral
- Referral contacts start with higher base trust (vouched for)

**Modify `contacts.ts`**:
- `processWeeklyContactDecay(state, rng)` — trust decays 1/week without interaction, contacts can drift away
- `evaluateBetrayalRisk(contact, state)` — low-loyalty contacts may leak your reports to rivals
- `generateExclusiveWindow(rng, contact, state)` — high-trust insiders give 2-week early access to prospects

**Modify `gameLoop.ts`**:
- Add `processWeeklyContactDecay` and `processGossipDecay` to `processWeeklyTick`
- Gossip items generate inbox messages

**UI: `NetworkScreen.tsx`** (380 lines):
- Trust meter visualization per contact
- Gossip feed showing latest intelligence
- Referral opportunities as actionable cards
- Warning indicators for contacts at risk of betrayal

### Checklist
- [x] Extend `Contact` with `trustLevel`, `loyalty`, `interactionHistory`, `gossipQueue`, `referralNetwork`, `betrayalRisk`, `exclusiveWindow`
- [x] Add `ContactInteraction` and `GossipItem` types to `types.ts`
- [x] Create `src/engine/network/gossip.ts` with gossip generation and decay
- [x] Create `src/engine/network/referrals.ts` with referral mechanics
- [x] Implement trust decay in `contacts.ts`
- [x] Implement betrayal evaluation logic
- [x] Implement exclusive window mechanic
- [x] Add gossip/referral processing to `processWeeklyTick` in `gameLoop.ts`
- [x] Add migration for new Contact fields
- [x] Update `NetworkScreen.tsx` with trust visualization and gossip feed
- [x] `npm run build` passes

---

## F4: Transfer Negotiation Phase

### Goal
Replace instant accept/reject transfers with a multi-step negotiation process featuring club personalities, counter-offers, add-ons, rival bids, and agent involvement.

### Current State
- `src/engine/firstTeam/clubResponse.ts` (385 lines) — instant decision logic
- `src/engine/core/transferWindow.ts` (481 lines) — transfer market mechanics
- `src/engine/world/transfers.ts` (513 lines) — AI transfer movement
- Transfers are currently binary: recommend → club accepts or rejects

### Architecture

**New types** in `types.ts`:
```typescript
interface TransferNegotiation {
  id: string;
  playerId: string;
  fromClubId: string;
  toClubId: string;
  phase: "initial" | "counterOffer" | "finalOffer" | "completed" | "collapsed";
  rounds: NegotiationRound[];
  maxRounds: number;            // 2-4 based on club patience
  rivalBids: RivalBid[];
  deadline: number;             // week when negotiation expires
  clubPersonality: "hardball" | "reasonable" | "desperate" | "prestige";
  agentInvolved: boolean;
  agentDemands?: { wagePremium: number; signingBonus: number };
}

interface NegotiationRound {
  roundNumber: number;
  offerAmount: number;
  askingAmount: number;
  addOns?: TransferAddOn[];
  response: "accepted" | "rejected" | "countered";
  week: number;
}

interface TransferAddOn {
  type: "appearanceBonus" | "sellOnClause" | "performanceBonus" | "relegationClause";
  value: number;
  trigger?: string;
}

interface RivalBid {
  clubId: string;
  amount: number;
  week: number;
  scoutName?: string;
}
```

**New file: `src/engine/firstTeam/negotiation.ts`** (~450 lines)
- `initiateNegotiation(rng, state, playerId, toClubId)` → creates TransferNegotiation
- `submitOffer(rng, state, negotiationId, amount, addOns?)` → processes offer
- `generateCounterOffer(rng, negotiation, clubPersonality)` → AI counter-offer logic
- `checkRivalBids(rng, state, negotiationId)` → rival clubs may bid (5-15% chance per round)
- `processAgentDemands(rng, player)` → agent wage/bonus demands based on player CA
- `evaluateNegotiationOutcome(negotiation)` → final acceptance check
- Club personality affects: starting price (+/- 20%), patience (rounds), willingness to include add-ons

**Modify `clubResponse.ts`**:
- Replace instant decision with `initiateNegotiation` call
- Keep the quick-decision path for simulated AI transfers (they don't need the full negotiation)

**Modify `gameStore.ts`**:
- Add `activeNegotiations: TransferNegotiation[]` to state
- Add actions: `initiateTransferNegotiation`, `submitTransferOffer`, `acceptNegotiation`, `walkAway`
- Negotiation rounds happen across weeks (submit offer → wait for response next week)

**Modify `gameLoop.ts`**:
- `processActiveNegotiations(state, rng)` — advance pending negotiations each week
- Rival bids checked each week for active negotiations

**UI: New `NegotiationScreen.tsx`** (~600 lines):
- Multi-round negotiation interface
- Offer/counter-offer comparison table
- Add-on builder (checkboxes for clause types)
- Rival bid warnings
- Club personality indicator (hints at negotiation strategy)
- Agent demand display
- "Walk away" option with reputation consequences

### Checklist
- [ ] Add `TransferNegotiation`, `NegotiationRound`, `TransferAddOn`, `RivalBid` types to `types.ts`
- [ ] Create `src/engine/firstTeam/negotiation.ts` with full negotiation logic
- [ ] Implement club personality system (hardball, reasonable, desperate, prestige)
- [ ] Implement multi-round offer/counter-offer flow
- [ ] Implement rival bid mechanics
- [ ] Implement agent involvement and demands
- [ ] Implement add-on clauses (appearance, sell-on, performance, relegation)
- [ ] Modify `clubResponse.ts` to use negotiation for player-initiated transfers
- [ ] Add `activeNegotiations` to `GameState`
- [ ] Add negotiation actions to `gameStore.ts`
- [ ] Wire `processActiveNegotiations` into `processWeeklyTick`
- [ ] Add migration for `activeNegotiations`
- [ ] Create `NegotiationScreen.tsx` with negotiation UI
- [ ] Add negotiation entry point from `PlayerProfile.tsx`
- [ ] `npm run build` passes

---

## F5: Match Tactical Layer

### Goal
Add formation/tactical depth to match simulation so team style influences event distribution, and counter-systems create strategic depth.

### Current State
- `src/engine/match/phases.ts` (549 lines) — event generation without tactical influence
- `src/engine/firstTeam/tacticalStyle.ts` (187 lines) — derives style from philosophy but doesn't affect matches
- `TacticalStyle` type exists (line 305 in types.ts) with `formation`, `playingStyle`, `pressingIntensity`, `buildUpStyle`
- Match events randomly weighted by attributes — no tactical influence

### Architecture

**Extend `TacticalStyle`** in `types.ts`:
```typescript
interface TacticalStyle {
  // existing fields...
  eventDistribution: Partial<Record<MatchEventType, number>>; // weight modifiers per event type
  strengthAgainst: string[];    // styles this counters
  weakAgainst: string[];        // styles this is weak to
}
```

**New types**:
```typescript
interface TacticalMatchup {
  homeStyle: string;
  awayStyle: string;
  homeModifier: number;        // -0.3 to +0.3 applied to home event quality
  awayModifier: number;
  eventShift: Partial<Record<MatchEventType, number>>; // event frequency adjustments
}

interface MatchSubstitution {
  minute: number;
  playerOutId: string;
  playerInId: string;
  tacticalReason: "injury" | "tactical" | "fatigue" | "redCard";
}
```

**New file: `src/engine/match/tactics.ts`** (~350 lines)
- `STYLE_EVENT_DISTRIBUTIONS` — how each playing style shifts event frequency:
  - `pressing`: +30% tackle, +20% interception, -10% buildUp
  - `possession`: +40% pass, +20% throughBall, -20% tackle
  - `counterAttack`: +30% sprint, +20% dribble, -30% possession
  - `directPlay`: +20% header, +20% cross, +30% aerialDuel, -20% pass
  - `tikTaka`: +40% pass, +30% throughBall, -30% header
- `calculateTacticalMatchup(homeStyle, awayStyle)` → modifier values
- `applyTacticalModifiers(baseEvents, matchup, team)` → adjusted event weights
- `generateSubstitutions(rng, match, injuries, cards)` → AI subs at half-time or after incidents

**Modify `phases.ts`**:
- `generateMatchPhases` accepts `TacticalMatchup` parameter
- Event type selection weighted by tactical style
- Event quality modified by tactical matchup advantage/disadvantage
- Substitution events generated at appropriate phases

**Modify `tacticalStyle.ts`**:
- Add `eventDistribution`, `strengthAgainst`, `weakAgainst` to each style derivation
- Map existing `playingStyle` values to distributions

**Modify `gameLoop.ts`**:
- `simulateFixture` loads both teams' tactical styles and calculates matchup before generating phases

### Checklist
- [x] Extend `TacticalStyle` with `eventDistribution`, `strengthAgainst`, `weakAgainst`
- [x] Add `TacticalMatchup` and `MatchSubstitution` types to `types.ts`
- [x] Create `src/engine/match/tactics.ts` with style distributions and matchup logic
- [x] Implement 5+ playing style distributions (pressing, possession, counter, direct, tikTaka)
- [x] Implement tactical matchup calculation (rock-paper-scissors element)
- [x] Implement substitution generation logic
- [x] Modify `generateMatchPhases` to accept and apply tactical modifiers
- [x] Modify `simulateFixture` to calculate matchup before phase generation
- [x] Wire tactical styles from club data into match pipeline
- [x] `npm run build` passes

---

## F6: Discipline/Card System

### Goal
Add yellow/red cards as match events, with accumulation tracking, suspensions, and scouting implications.

### Current State
- No card system exists
- Match events include `tackle` and `foul` types but no card consequences
- Players have `tackling` and `temperament` attributes that could drive card probability

### Architecture

**New types** in `types.ts`:
```typescript
interface CardEvent {
  type: "yellow" | "red";
  playerId: string;
  fixtureId: string;
  minute: number;
  reason: "recklessTackle" | "professionalFoul" | "dissent" | "timewasting" | "handball" | "violentConduct";
}

interface DisciplinaryRecord {
  playerId: string;
  season: number;
  yellowCards: number;
  redCards: number;
  suspensionWeeksRemaining: number;
  cardHistory: CardEvent[];
}
```

**Add to `Player`**: `disciplinaryRecord?: DisciplinaryRecord`

**Add to `GameState`**: `disciplinaryRecords: Record<string, DisciplinaryRecord>`

**New file: `src/engine/match/discipline.ts`** (~250 lines)
- `generateCardEvents(rng, phases, players)` — post-process match phases to check for cards
  - Tackle events with quality < 3 → 40% yellow, 5% red
  - Temperament < 8 → doubles card probability
  - Aggression attribute affects card frequency
- `processCardAccumulation(state, cards)` — track totals, trigger suspensions
  - 5 yellows = 1 match suspension
  - 10 yellows = 2 match suspension
  - Red card = 1-3 match suspension (based on reason)
- `getPlayerAvailability(player, state)` — returns `"available" | "suspended" | "injured"`
- `clearSeasonCards(state)` — reset at season end

**Modify `phases.ts`**:
- Add `card` to MatchEventType
- Card events generated inline during tackle/foul phases
- Red card reduces team to 10 men (lower event quality for remaining phases)

**Modify `gameLoop.ts`**:
- `processWeeklyTick` calls `processCardAccumulation` after fixture simulation
- Suspended players excluded from `simulateFixture` lineup selection

**Modify `ratings.ts`**:
- Yellow card: -0.3 to match rating
- Red card: rating capped at 3.0

**UI: `PlayerProfile.tsx`**:
- Show disciplinary record (yellow/red cards, suspensions)
- Warning when player close to suspension threshold

**UI: `MatchSummaryScreen.tsx`**:
- Card events in match timeline
- Suspended player notification

### Checklist
- [ ] Add `CardEvent` and `DisciplinaryRecord` types to `types.ts`
- [ ] Add `disciplinaryRecord` to `Player` type
- [ ] Add `disciplinaryRecords` to `GameState`
- [ ] Create `src/engine/match/discipline.ts` with card generation and accumulation
- [ ] Implement card probability formula (tackling quality, temperament, aggression)
- [ ] Implement 5-yellow and 10-yellow suspension thresholds
- [ ] Implement red card suspension (1-3 matches by reason)
- [ ] Add `card` event type to match phases
- [ ] Implement 10-man team quality reduction after red card
- [ ] Wire card processing into `processWeeklyTick`
- [ ] Exclude suspended players from fixture simulation
- [ ] Integrate cards with match rating system (-0.3 yellow, cap 3.0 red)
- [ ] Add migration for `disciplinaryRecords`
- [ ] Update `PlayerProfile.tsx` with disciplinary display
- [ ] Update `MatchSummaryScreen.tsx` with card events
- [ ] Add season-end card reset
- [ ] `npm run build` passes

---

## F7: Injury System Overhaul

### Goal
Add match injuries, recovery tracking, injury-prone traits, and scouting implications for injuries.

### Current State
- `gameLoop.ts` has `processInjuries` and `computeInjuryProbability` functions (lines 632-680)
- Players have `stamina` attribute and `injuryDuration` field
- Injury system exists but is basic — no match injuries, no injury types, no scouting impact

### Architecture

**New types** in `types.ts`:
```typescript
interface Injury {
  id: string;
  playerId: string;
  type: "muscle" | "ligament" | "fracture" | "concussion" | "knock" | "fatigue";
  severity: "minor" | "moderate" | "serious" | "career-threatening";
  recoveryWeeks: number;
  weeksRemaining: number;
  occurredInMatch?: string;     // fixtureId
  minute?: number;
  reinjuryRisk: number;        // 0-1, elevated for 4 weeks after return
}

interface InjuryHistory {
  playerId: string;
  injuries: Injury[];
  totalWeeksMissed: number;
  injuryProneness: number;     // 0-1, increases with repeated injuries
}
```

**Add to `Player`**: `injuryHistory?: InjuryHistory`, `currentInjury?: Injury`

**Modify existing**: Replace simple `injuryDuration: number` with the richer `currentInjury` system.

**Modify `src/engine/core/gameLoop.ts`** (`processInjuries`):
- Replace simple duration tracking with `Injury` objects
- Match injuries: 2-5% chance per match per player, modified by stamina and match intensity
- Injury type distribution: muscle 40%, knock 25%, ligament 15%, fatigue 10%, fracture 7%, concussion 3%
- Recovery times: knock 1-2 weeks, muscle 2-6 weeks, fatigue 1-3 weeks, ligament 4-12 weeks, fracture 6-16 weeks, concussion 2-4 weeks
- Injury-prone players: repeated injuries increase `injuryProneness`, which increases future risk
- Reinjury risk: 4-week window after return where injury chance is doubled

**Modify `phases.ts`**:
- Injury events during matches (sprint, tackle events can cause injuries)
- Injury forces player off (substitution event)

**Scouting integration**:
- Injury history visible in `PlayerProfile.tsx`
- Injury-prone flag in scouting reports
- Injured players can't be observed at matches
- Discount scouting: injured star players can be recommended at lower prices

**UI: `PlayerProfile.tsx`**:
- Injury history timeline
- Current injury status with recovery countdown
- Injury-prone warning indicator

### Checklist
- [x] Add `Injury` and `InjuryHistory` types to `types.ts`
- [x] Add `injuryHistory` and `currentInjury` to `Player` type
- [x] Overhaul `processInjuries` in `gameLoop.ts` with new injury system
- [x] Implement injury type distribution and severity calculation
- [x] Implement recovery time ranges per injury type
- [x] Implement injury-proneness accumulation
- [x] Implement reinjury risk window (4 weeks post-return)
- [x] Add match injury events to `phases.ts`
- [x] Add injury-related substitution events
- [x] Exclude injured players from fixture simulation
- [x] Add injury history to `PlayerProfile.tsx`
- [x] Add injury-prone flag to scouting report considerations
- [x] Add migration for new Player injury fields
- [x] `npm run build` passes (no new errors; pre-existing CalendarScreen/PlayerDatabase/gameStore issues remain)

---

## F8: Rival Scouts Enhancement

### Goal
Make rival scouts active competitors who appear at matches, target the same players, create urgency, and force strategic timing decisions.

### Current State
- `src/engine/rivals/rivalScouts.ts` (478 lines) — 4 personality types defined
- `RivalScout` type has `personality`, `targetPlayers`, `reputation`
- Basic system exists but rivals don't actively compete for targets

### Architecture

**Extend `RivalScout`** in `types.ts`:
```typescript
interface RivalScout {
  // existing fields...
  currentTarget?: string;         // playerId being actively scouted
  scoutingProgress: Record<string, number>; // playerId → observation count (0-5)
  reportDeadline?: number;        // week when rival submits report
  lastSeenAtFixture?: string;     // fixtureId where rival was spotted
  aggressiveness: number;         // 0-1, how quickly they move
  budgetTier: "low" | "medium" | "high"; // affects targets they can recommend
}
```

**New types**:
```typescript
interface RivalActivity {
  rivalId: string;
  type: "spotted" | "targetAcquired" | "reportSubmitted" | "playerSigned";
  playerId?: string;
  fixtureId?: string;
  week: number;
}
```

**Modify `rivalScouts.ts`**:
- `processRivalScoutWeek(rng, state)` — weekly rival AI:
  1. Select targets based on personality (aggressive → high CA, methodical → value picks, bargain → low CA/high PA)
  2. Attend matches where targets play (visible to player if at same match)
  3. Build scouting progress (2-4 weeks to complete)
  4. Submit reports (player loses exclusive access)
  5. If rival reports first and club signs, player loses the opportunity
- `checkRivalPresence(state, fixtureId)` — returns rivals at same match
- `generateRivalIntelligence(rng, state, contacts)` — contacts warn about rival activity

**Modify `gameLoop.ts`**:
- Add `processRivalScoutWeek` to `processWeeklyTick`
- Rivals generate inbox messages when spotted or when they sign a target

**Modify `gameStore.ts`**:
- Track `rivalActivities: RivalActivity[]` for display
- Migration: existing rival scouts get new fields

**UI: `RivalsScreen.tsx`** (216 lines):
- Active rival targets with progress bars
- Match overlap warnings ("Victor Mendes will be at this match")
- Rivalry history (who beat whom to targets)
- Contact tips about rival movements

**UI: `MatchScreen.tsx`** (632 lines):
- Rival scout visible in attendance when at same match
- Creates tension during observation

### Checklist
- [x] Extend `RivalScout` with `currentTarget`, `scoutingProgress`, `reportDeadline`, `aggressiveness`, `budgetTier`
- [x] Add `RivalActivity` type to `types.ts`
- [x] Implement `processRivalScoutWeek` AI logic in `rivalScouts.ts`
- [x] Implement rival target selection by personality type
- [x] Implement rival scouting progress system (2-4 weeks per target)
- [x] Implement rival report submission and player loss mechanic
- [x] Implement `checkRivalPresence` for match overlap detection
- [x] Implement contact intelligence about rival movements
- [x] Wire `processRivalScoutWeek` into `processWeeklyTick`
- [x] Add `rivalActivities` to `GameState` and migration
- [x] Update `RivalsScreen.tsx` with progress bars and rival targets
- [x] Update `MatchScreen.tsx` to show rival presence
- [x] Generate inbox messages for rival activity
- [x] `npm run build` passes

---

## F9: Player Personality System

### Goal
Give players distinct personalities that affect transfer willingness, dressing room impact, form volatility, and big-match temperament. Personality is partially hidden — deeper scouting required to reveal it.

### Current State
- `src/engine/players/personality.ts` (216 lines) — personality trait definitions
- `src/engine/players/personalityReveal.ts` (209 lines) — trait discovery mechanics
- `src/engine/players/behavioralTraits.ts` (134 lines) — behavioral trait system
- `PersonalityTrait` type exists (line 190 in types.ts)
- `PlayerTrait` type exists (line 258)
- System is partially built but personality doesn't meaningfully affect gameplay

### Architecture

**Extend `PersonalityTrait`** or add `PersonalityProfile` in `types.ts`:
```typescript
interface PersonalityProfile {
  archetype: "leader" | "mercenary" | "homesick" | "ambitious" | "loyal" |
             "disruptive" | "introvert" | "professional" | "hothead" | "clutch";
  traits: PersonalityTrait[];
  transferWillingness: number;    // 0-1 (mercenary=0.9, loyal=0.2)
  dressingRoomImpact: number;     // -3 to +3 (leader=+3, disruptive=-2)
  formVolatility: number;         // 0-1 (professional=0.2, hothead=0.8)
  bigMatchModifier: number;       // -2 to +2 (clutch=+2, introvert=-1)
  hiddenUntilRevealed: boolean;   // requires deep scouting to see archetype
  revealedTraits: PersonalityTrait[]; // what the scout has uncovered so far
}
```

**Add to `Player`**: `personalityProfile?: PersonalityProfile`

**New file: `src/engine/players/personalityEffects.ts`** (~300 lines)
- `generatePersonalityProfile(rng, player)` — assigns archetype and trait scores at player generation
- `applyPersonalityToForm(profile, baseForm)` — volatility modifier
- `applyPersonalityToMatchRating(profile, baseRating, isImportantMatch)` — big match modifier
- `evaluateTransferWillingness(profile, currentClub, targetClub)` — how likely to accept move
- `evaluateDressingRoomImpact(profile, teamPersonalities)` — team chemistry effect
- `revealPersonalityTrait(rng, scout, player, observationCount)` — progressive discovery

**Modify `generation.ts`** in `src/engine/players/`:
- All generated players get a `personalityProfile` via `generatePersonalityProfile`

**Modify `ratings.ts`**:
- `calculatePlayerMatchRating` applies `bigMatchModifier` for important fixtures (top of table clashes, cup finals, etc.)
- Form update applies `formVolatility` (high volatility = bigger swings)

**Modify `perception.ts`** in `src/engine/scout/`:
- Multiple observations progressively reveal personality traits
- 1st observation: reveals 0-1 traits
- 3rd observation: reveals archetype
- 5th observation: full personality profile visible

**UI: `PlayerProfile.tsx`**:
- Personality section showing revealed traits and archetype
- Unknown traits shown as "?" with observation count needed
- Personality compatibility indicator for target clubs

**UI: `ReportWriter.tsx`**:
- Personality section in scouting reports
- "Character risk" assessment based on revealed traits

### Checklist
- [ ] Add `PersonalityProfile` type to `types.ts`
- [ ] Add `personalityProfile` to `Player` type
- [ ] Create `src/engine/players/personalityEffects.ts` with archetype effects
- [ ] Implement 10 personality archetypes with distinct gameplay effects
- [ ] Implement transfer willingness calculation
- [ ] Implement dressing room impact mechanics
- [ ] Implement form volatility modifier
- [ ] Implement big match performance modifier
- [ ] Wire personality generation into `generation.ts`
- [ ] Implement progressive personality reveal in `perception.ts`
- [ ] Apply personality to match ratings
- [ ] Apply personality to form calculations
- [ ] Add migration for `personalityProfile` on Player
- [ ] Update `PlayerProfile.tsx` with personality display
- [ ] Update `ReportWriter.tsx` with character assessment
- [ ] `npm run build` passes

---

## F10: Dynamic Board Expectations

### Goal
Make board directives reactive to scout performance, with escalating pressure, budget consequences, and multiple board personality types.

### Current State
- `src/engine/firstTeam/directives.ts` (488 lines) — directive generation and evaluation
- `BoardDirective` type (line 1483 in types.ts) — static objectives
- Board sets targets but doesn't react to ongoing performance

### Architecture

**Extend `BoardDirective`** or add `BoardProfile` in `types.ts`:
```typescript
interface BoardProfile {
  personality: "patient" | "impatient" | "penny-pinching" | "ambitious" | "hands-off";
  patience: number;              // 0-100, decreases with failed directives
  satisfactionLevel: number;     // 0-100, affects budget and job security
  budgetMultiplier: number;      // 0.5-2.0, based on satisfaction
  ultimatumIssued: boolean;
  ultimatumDeadline?: number;    // week
  recentDirectives: string[];    // history of directive types issued
}

interface BoardReaction {
  type: "praise" | "warning" | "budgetIncrease" | "budgetCut" | "ultimatum" | "demotion" | "firing";
  trigger: string;
  week: number;
  message: string;
}
```

**Add to `GameState`**: `boardProfile: BoardProfile`, `boardReactions: BoardReaction[]`

**New file: `src/engine/firstTeam/boardAI.ts`** (~300 lines)
- `evaluateBoardSatisfaction(state, rng)` — weekly assessment:
  - Successful recommendations → satisfaction +5
  - Failed recommendations → satisfaction -8
  - Missed directive deadlines → satisfaction -15
  - Idle weeks (no reports submitted) → satisfaction -1
- `generateBoardReaction(state, rng)` — threshold-based reactions:
  - Satisfaction > 80 → "praise" + budget increase
  - Satisfaction 60-80 → neutral
  - Satisfaction 40-60 → "warning" message
  - Satisfaction 20-40 → "budgetCut" + "ultimatum"
  - Satisfaction < 20 → "firing" (game over) or "demotion" (drop tier)
- `adjustDirectiveDifficulty(state, boardProfile)` — ambitious boards escalate targets
- Board personality affects all thresholds (patient = wider neutral band, impatient = narrow)

**Modify `directives.ts`**:
- Directive targets scale with board satisfaction
- High satisfaction → reasonable targets with flexibility
- Low satisfaction → strict targets with tight deadlines

**Modify `gameStore.ts`**:
- Add `boardProfile` and `boardReactions` to state
- Add `meetBoard()` action that temporarily improves satisfaction
- Board reactions generate inbox messages

**UI: `Dashboard.tsx`** (1,399 lines):
- Board satisfaction meter
- Current directive urgency indicator
- Warning when approaching firing threshold

### Checklist
- [x] Add `BoardProfile` and `BoardReaction` types to `types.ts`
- [x] Add `boardProfile` and `boardReactions` to `GameState`
- [x] Create `src/engine/firstTeam/boardAI.ts` with satisfaction evaluation and reactions
- [x] Implement 5 board personality types with distinct behavior
- [x] Implement satisfaction tracking with positive/negative triggers
- [x] Implement budget multiplier based on satisfaction
- [x] Implement ultimatum mechanic (deadline + consequences)
- [x] Implement demotion/firing for extreme dissatisfaction
- [x] Modify `directives.ts` for scaling difficulty
- [x] Add board reaction generation to `processWeeklyTick`
- [x] Add `meetBoard` action to `gameStore.ts`
- [x] Add migration for `boardProfile` and `boardReactions`
- [x] Update `Dashboard.tsx` with board satisfaction display
- [x] `npm run build` passes

---

## F11: Scouting Report Comparison Tool

### Goal
Let players compare 2-3 scouted players side-by-side with radar charts, cost analysis, and position suitability.

### Current State
- `src/engine/reports/reporting.ts` (666 lines) — report generation
- `ScoutReport` type has attribute assessments, conviction, strengths, weaknesses
- No comparison functionality exists

### Architecture

**New file: `src/engine/reports/comparison.ts`** (~200 lines)
- `compareReports(reports: ScoutReport[])` → comparison data structure
- `calculateValueScore(report, transferFee)` → value-for-money metric
- `calculatePositionFit(report, targetPosition, clubStyle)` → fit percentage
- `generateComparisonSummary(reports)` → text summary of key differences

**New UI: `src/components/game/ReportComparison.tsx`** (~500 lines)
- Side-by-side cards for 2-3 players
- Radar chart overlay (using existing attribute data)
- Key metrics table: CA estimate, PA estimate, age, fee, value score
- Strengths/weaknesses comparison matrix
- Position suitability bars
- "Best pick" recommendation based on directives
- Entry point: select reports from `ReportHistory.tsx`

**Modify `gameStore.ts`**:
- Add `comparisonReportIds: string[]` to track selected reports for comparison
- Add `addToComparison(reportId)`, `removeFromComparison(reportId)`, `clearComparison()` actions

### Checklist
- [x] Create `src/engine/reports/comparison.ts` with comparison logic
- [x] Implement `compareReports` with attribute delta calculation
- [x] Implement `calculateValueScore` metric
- [x] Implement `calculatePositionFit` metric
- [x] Create `src/components/game/ReportComparison.tsx` with comparison UI
- [x] Add radar chart visualization for attribute overlay
- [x] Add key metrics comparison table
- [x] Add comparison selection to `ReportHistory.tsx`
- [x] Add `comparisonReportIds` and actions to `gameStore.ts`
- [x] `npm run build` passes (tsc --noEmit: 0 errors; next build: compiles + type-checks OK)

---

## F12: Youth Pipeline Tracking

### Goal
Track youth prospects after placement with career updates, success metrics, and alumni-to-contact pipeline.

### Current State
- `src/engine/youth/alumni.ts` (402 lines) — alumni milestone tracking (partially implemented)
- `AlumniRecord` and `AlumniMilestone` types exist
- `src/components/game/AlumniDashboard.tsx` (306 lines) — UI exists
- Youth prospects disappear into a void after placement

### Architecture

**Extend `AlumniRecord`** in `types.ts`:
```typescript
interface AlumniRecord {
  // existing fields...
  careerUpdates: AlumniCareerUpdate[];
  currentStatus: "academy" | "firstTeam" | "loaned" | "released" | "retired" | "transferred";
  seasonStats: AlumniSeasonStats[];
  becameContact: boolean;        // graduated to contact network
}

interface AlumniCareerUpdate {
  week: number;
  season: number;
  type: "debut" | "firstGoal" | "teamOfWeek" | "loanMove" | "transfer" | "released" | "internationalCall" | "injury" | "captaincy";
  description: string;
}

interface AlumniSeasonStats {
  season: number;
  appearances: number;
  goals: number;
  assists: number;
  avgRating: number;
  clubId: string;
}
```

**Modify `alumni.ts`**:
- `processAlumniWeek` generates career updates based on player development
- `checkAlumniMilestones` — first team debut, first goal, international call-up
- `promoteAlumniToContact(state, alumniId)` — former placements who make it can become contacts
- `generateAlumniSeasonSummary(rng, alumni, state)` — end-of-season recap

**Modify `gameLoop.ts`**:
- Enhance `processAlumniWeek` to generate career updates using player match data
- Alumni who reach first-team status generate inbox messages

**UI: `AlumniDashboard.tsx`** (306 lines):
- Career timeline visualization per alumni
- Season-by-season stats table
- "Graduated to Contact" badge
- Placement success rate metric
- Highlight biggest alumni successes

### Checklist
- [x] Extend `AlumniRecord` with `careerUpdates`, `currentStatus`, `seasonStats`, `becameContact`
- [x] Add `AlumniCareerUpdate` and `AlumniSeasonStats` types
- [x] Implement career update generation in `alumni.ts`
- [x] Implement milestone detection (debut, goals, international call-up)
- [x] Implement alumni-to-contact promotion
- [x] Implement season summary generation
- [x] Wire enhanced alumni processing into `processWeeklyTick`
- [x] Update `AlumniDashboard.tsx` with career timelines and stats
- [x] Add inbox messages for notable alumni achievements
- [x] Add migration for extended `AlumniRecord` fields
- [x] `npm run build` passes

---

## F13: Regional Scouting Depth

### Goal
Rebalance regional specialization and add region-specific knowledge, hidden leagues, cultural insights, and local contacts.

### Current State
- `src/engine/specializations/perks.ts` (682 lines) — perk definitions including regional
- Regional spec gives 70% error reduction (potentially overpowered)
- `src/engine/world/regions.ts` (171 lines) — regional structures
- 24 countries, 6 core + 18 secondary

### Architecture

**New types** in `types.ts`:
```typescript
interface RegionalKnowledge {
  countryId: string;
  knowledgeLevel: number;        // 0-100
  discoveredLeagues: string[];   // hidden league IDs unlocked
  culturalInsights: CulturalInsight[];
  localContacts: string[];       // auto-generated contact IDs
  scoutingEfficiency: number;    // 0.5-1.5 multiplier on observation quality
}

interface CulturalInsight {
  type: "playingStyle" | "developmentCulture" | "mentalityPattern" | "physicalTrait";
  description: string;
  gameplayEffect: string;        // what it unlocks or reveals
}

interface HiddenLeague {
  id: string;
  countryId: string;
  name: string;
  tier: number;                  // lower-tier leagues
  discoveryThreshold: number;    // knowledgeLevel needed to find it
  playerQualityRange: [number, number]; // CA range of players
  talentDensity: number;         // probability of high-PA players
}
```

**New file: `src/engine/world/hiddenLeagues.ts`** (~250 lines)
- `HIDDEN_LEAGUE_DEFINITIONS` — 15-20 hidden leagues across regions
- `discoverHiddenLeague(rng, state, countryId, knowledgeLevel)` — unlock check
- `generateHiddenLeaguePlayers(rng, league)` — populate with players

**New file: `src/engine/specializations/regionalKnowledge.ts`** (~250 lines)
- `processRegionalKnowledgeGrowth(state, rng)` — knowledge increases with scouting activity in region
- `generateCulturalInsight(rng, country, knowledgeLevel)` — periodic insights
- `generateLocalContact(rng, country, knowledgeLevel)` — auto-contacts at knowledge thresholds
- `calculateScoutingEfficiency(knowledgeLevel)` — replaces flat 70% reduction with graduated curve

**Rebalance regional perk** in `perks.ts`:
- Replace 70% flat error reduction with graduated curve:
  - Knowledge 0-25: 15% error reduction
  - Knowledge 25-50: 30% error reduction
  - Knowledge 50-75: 50% error reduction
  - Knowledge 75-100: 70% error reduction
- Knowledge grows through repeated scouting in the same region

**UI: `WorldMap.tsx`** (534 lines):
- Knowledge level indicators per country
- Hidden league discovery notifications
- Cultural insight cards on country popup

### Checklist
- [x] Add `RegionalKnowledge`, `CulturalInsight`, `HiddenLeague` types to `types.ts`
- [x] Create `src/engine/world/hiddenLeagues.ts` with hidden league definitions
- [x] Define 15-20 hidden leagues across regions
- [x] Create `src/engine/specializations/regionalKnowledge.ts` with knowledge growth
- [x] Implement graduated error reduction curve (replace flat 70%)
- [x] Implement cultural insight generation
- [x] Implement local contact auto-generation at knowledge thresholds
- [x] Implement hidden league discovery mechanic
- [x] Wire knowledge growth into weekly processing
- [x] Add `regionalKnowledge` to `GameState` and migration
- [x] Update `WorldMap.tsx` with knowledge indicators
- [x] Update `CountryPopup.tsx` with insights and hidden leagues
- [x] `npm run build` passes

---

## F14: Financial Strategy Layer

### Goal
Add strategic financial choices: scouting infrastructure investment, assistant scouts, trip quality tiers, and salary negotiation.

### Current State
- `src/engine/finance/` (4,362 lines across 20 files) — detailed economy system
- 8 revenue streams, 5 expense categories, debt system
- Equipment catalog exists but no scouting infrastructure investment
- No assistant scout hiring for general scouting tasks

### Architecture

**New types** in `types.ts`:
```typescript
interface ScoutingInfrastructure {
  dataSubscription: "none" | "basic" | "premium" | "elite";  // affects data quality
  travelBudget: "economy" | "standard" | "business";          // affects fatigue
  officeEquipment: "basic" | "upgraded" | "professional";     // affects report quality
  investmentCosts: { weekly: number; oneTime: number };
}

interface AssistantScout {
  id: string;
  name: string;
  skill: number;                // 1-10 (affects observation quality)
  salary: number;
  assignedPlayerId?: string;
  assignedRegion?: string;
  fatigue: number;
  reportsCompleted: number;
}

interface TripQuality {
  level: "budget" | "standard" | "premium";
  costMultiplier: number;        // 0.5, 1.0, 1.8
  fatigueMultiplier: number;     // 1.5, 1.0, 0.6
  observationBonus: number;      // -0.1, 0, +0.15
}

interface SalaryNegotiation {
  currentSalary: number;
  proposedSalary: number;
  clubBudget: number;
  scoutReputation: number;
  counterOffers: number;
}
```

**New file: `src/engine/finance/scoutingInvestment.ts`** (~250 lines)
- `purchaseDataSubscription(state, tier)` — improve data scouting quality
- `upgradeTravelBudget(state, tier)` — reduce travel fatigue
- `upgradeOfficeEquipment(state, tier)` — improve report quality
- `calculateInfrastructureEffects(infrastructure)` — aggregate bonuses

**New file: `src/engine/finance/assistantScouts.ts`** (~200 lines)
- `hireAssistantScout(rng, state)` — hire with randomized skill level
- `assignAssistantScout(state, scoutId, task)` — assign to player or region
- `processAssistantScoutWeek(state, rng)` — generate lower-quality observations
- `fireAssistantScout(state, scoutId)` — remove

**Modify `gameStore.ts`**:
- Add infrastructure and assistant scout actions
- Add salary negotiation at career milestones

**UI: `FinancialDashboard.tsx`** (880 lines):
- Infrastructure investment panel
- Assistant scout management
- Trip quality selector per travel booking
- ROI calculations for investments

### Checklist
- [ ] Add `ScoutingInfrastructure`, `AssistantScout`, `TripQuality` types to `types.ts`
- [ ] Create `src/engine/finance/scoutingInvestment.ts` with investment mechanics
- [ ] Implement 3-tier data subscription system
- [ ] Implement travel budget tiers affecting fatigue
- [ ] Implement office equipment tiers affecting report quality
- [ ] Create `src/engine/finance/assistantScouts.ts` with assistant management
- [ ] Implement assistant scout hiring/firing/assignment
- [ ] Implement assistant scout weekly processing (lower-quality observations)
- [ ] Add infrastructure and assistant scout state to `GameState`
- [ ] Add migration for new financial fields
- [ ] Update `FinancialDashboard.tsx` with investment panels
- [ ] Wire infrastructure bonuses into observation/report/travel systems
- [ ] `npm run build` passes

---

## F15: Match Commentary Enhancement

### Goal
Make match commentary position-aware, form-aware, and narratively connected to scouting context.

### Current State
- `src/engine/match/commentary.ts` (594 lines) — 25+ event templates
- Templates are generic ("Player makes a tackle")
- No position context, no form context, no scouting callbacks

### Architecture

**Modify `commentary.ts`**:
- Expand template system to include position-specific variants:
  ```typescript
  interface CommentaryTemplate {
    generic: string;
    byPosition?: Partial<Record<Position, string>>;
    formAware?: { highForm: string; lowForm: string };
    scoutingRelevant?: string;    // shown when player is being observed
  }
  ```
- Each of 25+ event types gets 3-5 position variants
- Form-aware variants: "continuing his excellent run" vs "another poor display"
- Scouting variants: "exactly the kind of ball progression you flagged"

**New file: `src/engine/match/commentaryTemplates.ts`** (~600 lines)
- Position-specific templates for all event types
- Form-based modifiers
- Scouting context strings
- Historical reference generator ("just like his performance against...")

**Modify `phases.ts`**:
- Pass player position, form, and scouting focus to commentary generation
- Select appropriate template variant based on context

### Checklist
- [x] Define `CommentaryTemplate` interface with position, form, and scouting variants
- [x] Create `src/engine/match/commentaryTemplates.ts` with expanded templates
- [x] Write position-specific variants for all 25+ event types (100+ new templates)
- [x] Implement form-aware commentary selection
- [x] Implement scouting-relevant commentary for focused players
- [x] Implement historical reference system ("just like last month against...")
- [x] Modify `phases.ts` to pass context to commentary generation
- [x] Update `commentary.ts` to use new template system
- [x] `npm run build` passes

---

## F16: Calendar Week Preview

### Goal
Show upcoming opportunities before the week starts: matches with targets, fixture congestion, and scheduling suggestions.

### Current State
- `src/components/game/CalendarScreen.tsx` (518 lines) — week scheduling UI
- No preview of upcoming fixtures or optimization suggestions
- Players schedule blind, hoping to find matches worth attending

### Architecture

**New file: `src/engine/core/weekPreview.ts`** (~200 lines)
- `generateWeekPreview(state)` → preview data:
  - Matches this week featuring tracked/targeted players
  - Matches featuring players in active directives
  - Fixture congestion indicator (more matches = more fatigue)
  - Travel requirements for each match
  - Suggested optimal schedule based on priorities
- `suggestOptimalSchedule(state, priorities)` → recommended day assignments

**Modify `CalendarScreen.tsx`**:
- Preview panel at top showing:
  - "3 matches this week with your targets"
  - "Liverpool vs Arsenal (your target Salah is playing)"
  - "Heavy travel week — consider rest day"
  - Suggested schedule (one-click apply)
- Match list with player highlights

### Checklist
- [x] Create `src/engine/core/weekPreview.ts` with preview generation
- [x] Implement target player match detection
- [x] Implement directive-relevant match highlighting
- [x] Implement fixture congestion calculation
- [x] Implement schedule suggestion algorithm
- [x] Update `CalendarScreen.tsx` with preview panel
- [x] Add suggested schedule one-click apply
- [x] `npm run build` passes (F16 code compiles clean; unrelated error in F13 regionalKnowledge.ts)

---

## F17: Quick Scout Mode

### Goal
For experienced players: auto-schedule, batch-advance, and delegate scouting to NPC scouts with trade-offs.

### Current State
- NPC scouts exist (`career/npcScouts.ts`, 573 lines) but only available at Tier 4+
- No batch advancement or auto-scheduling
- Manual scheduling required every week

### Architecture

**New file: `src/engine/core/quickScout.ts`** (~250 lines)
- `autoScheduleWeek(state, priorities)` — fill empty days with optimal activities:
  - Match observations for priority targets
  - Training on weakest skills
  - Rest when fatigue > 70
  - Contact meetings when trust decaying
- `batchAdvanceWeeks(state, rng, weeks)` — advance multiple weeks with summary:
  - Process each week normally
  - Collect all events, ratings, messages
  - Return condensed summary
- `delegateScoutingTask(state, npcScoutId, playerId)` — assign NPC to full observation:
  - NPC generates lower-quality observations (skill-dependent)
  - Takes 2-3 weeks depending on NPC skill
  - Returns preliminary report

**Modify `gameStore.ts`**:
- Add `autoSchedule()`, `batchAdvance(weeks)`, `delegateScouting(npcId, playerId)` actions
- `batchAdvance` shows condensed summary screen

**New UI: `src/components/game/BatchSummary.tsx`** (~300 lines)
- Multi-week summary view
- Key events highlighted (narrative events, rival activity, notable matches)
- Player development changes
- Financial summary

### Checklist
- [ ] Create `src/engine/core/quickScout.ts` with auto-schedule logic
- [ ] Implement `autoScheduleWeek` with priority-based scheduling
- [ ] Implement `batchAdvanceWeeks` with multi-week processing
- [ ] Implement `delegateScoutingTask` for NPC delegation
- [ ] Add actions to `gameStore.ts`
- [ ] Create `src/components/game/BatchSummary.tsx` for batch results
- [ ] Add auto-schedule button to `CalendarScreen.tsx`
- [ ] Add batch advance option to weekly flow
- [ ] `npm run build` passes

---

## F18: Achievement System

### Goal
Unlock achievements for memorable accomplishments, encouraging diverse playstyles and replayability.

### Current State
- `src/engine/finance/awards.ts` (91 lines) — basic award system
- `src/components/game/AchievementScreen.tsx` (231 lines) — UI exists
- `src/stores/achievementStore.ts` (151 lines) — tracking store
- Foundation exists but achievements are minimal

### Architecture

**Extend achievement definitions** in `awards.ts`:

30+ achievements across categories:
- **Discovery**: "Diamond in the Rough" (CA<80 → star), "Eye for Talent" (5 correct PA predictions)
- **Completion**: "Globe Trotter" (scout all 24 countries), "Full House" (one report per position)
- **Youth**: "Youth Whisperer" (20 placed youth reach first team), "Academy Gold" (youth placement averages 7+ rating)
- **Performance**: "Perfect Record" (100% hit rate 10+ recs), "Streak" (5 consecutive successful recommendations)
- **Challenge**: "Against All Odds" (hardest scenario complete), "Speedrun" (tier 5 in under 10 seasons)
- **Social**: "Network Master" (15+ contacts at high trust), "Diplomat" (negotiation success rate > 80%)
- **Financial**: "Self-Made" (0 debt, 500k savings), "Big Spender" (complete infrastructure upgrade)
- **Match**: "Eagle Eye" (attend 100 matches), "Analyst" (observe 500 events)

**New file: `src/engine/core/achievementEngine.ts`** (~300 lines)
- `checkAchievements(state)` — evaluates all achievement conditions
- `unlockAchievement(state, achievementId)` — marks as unlocked with timestamp
- Achievement conditions are declarative (predicate functions per achievement)

**Modify `gameLoop.ts`**:
- Call `checkAchievements` at end of each weekly tick

**Modify `achievementStore.ts`**:
- Store unlocked achievements persistently (across saves)
- Track progress toward locked achievements (50/100 matches attended)

**UI: `AchievementScreen.tsx`** (231 lines):
- Grid of achievement cards (locked/unlocked)
- Progress bars for in-progress achievements
- Rarity indicators
- Toast notification on unlock

### Checklist
- [ ] Define 30+ achievements across 7+ categories in `awards.ts`
- [ ] Create `src/engine/core/achievementEngine.ts` with condition checking
- [ ] Implement declarative achievement conditions (predicate functions)
- [ ] Implement progress tracking for multi-step achievements
- [ ] Wire `checkAchievements` into `processWeeklyTick`
- [ ] Update `achievementStore.ts` with persistent unlock tracking
- [ ] Update `AchievementScreen.tsx` with progress bars and categories
- [ ] Implement `AchievementToast.tsx` for unlock notifications
- [ ] `npm run build` passes

---

## F19: New Game+ / Legacy Mode

### Goal
After career completion, retain some knowledge/contacts and unlock harder scenarios for replayability.

### Current State
- `src/components/game/HallOfFame.tsx` (308 lines) — career summary exists
- No carry-over mechanics between careers
- No difficulty modifiers beyond scenarios

### Architecture

**New types** in `types.ts`:
```typescript
interface LegacyProfile {
  id: string;
  completedCareers: CompletedCareer[];
  unlockedScenarios: string[];
  legacyPerks: LegacyPerk[];
  totalDiscoveries: number;
  totalSeasonsPlayed: number;
  bestHitRate: number;
}

interface CompletedCareer {
  scoutName: string;
  finalTier: number;
  seasonsPlayed: number;
  totalDiscoveries: number;
  hitRate: number;
  specialization: string;
  completedScenarios: string[];
}

interface LegacyPerk {
  id: string;
  type: "startingContact" | "reputationBoost" | "skillBonus" | "budgetBonus" | "knowledgeRetain";
  value: number;
  unlockedBy: string;           // achievement or career milestone
}
```

**New file: `src/engine/career/legacy.ts`** (~250 lines)
- `generateLegacyProfile(completedState)` — create profile from finished career
- `applyLegacyPerks(newGameConfig, legacyProfile)` — modify new game start
- `checkScenarioUnlocks(profile)` — unlock harder scenarios based on prior achievement
- Legacy perks:
  - "Starting Network" — begin with 2 contacts from prior career
  - "Reputation Head Start" — +10 starting reputation
  - "Regional Memory" — retain 25% of regional knowledge
  - "Financial Cushion" — +20% starting budget

**Modify `NewGameScreen.tsx`** (1,266 lines):
- "New Game+" option when legacy profile exists
- Legacy perk selection screen
- Unlocked scenario indicators
- Career history summary

**Modify `gameStore.ts`**:
- `completeLegacyCareer()` — generate legacy profile on career end
- `startNewGamePlus(config, legacyProfile)` — new game with perks applied
- Persist `legacyProfile` in localStorage (outside game saves)

### Checklist
- [x] Add `LegacyProfile`, `CompletedCareer`, `LegacyPerk` types to `types.ts`
- [x] Create `src/engine/career/legacy.ts` with legacy mechanics
- [x] Implement `generateLegacyProfile` from completed career state
- [x] Implement `applyLegacyPerks` for new game modifications
- [x] Implement scenario unlock conditions
- [x] Define 6+ legacy perks with meaningful bonuses
- [x] Modify `NewGameScreen.tsx` with New Game+ flow
- [x] Add `completeLegacyCareer` and `startNewGamePlus` to `gameStore.ts`
- [x] Persist legacy profile in localStorage
- [x] `npm run build` passes

---

## F20: Data Visualization Dashboard

### Goal
Rich data visualizations for the data scout specialization: scatter plots, heat maps, trend lines, and league comparisons.

### Current State
- `src/engine/data/` (1,489 lines) — data analysis, anomaly detection, predictions
- `src/components/game/AnalyticsScreen.tsx` (377 lines) — basic analytics UI
- `src/engine/analytics/dataTension.ts` (278 lines) — data tension mechanics
- Data presentation is text-heavy, no charts or visualizations

### Architecture

**New UI component: `src/components/game/DataVisualization.tsx`** (~500 lines)
- Reusable chart components built with CSS (no external chart libraries to keep bundle small):
  - `ScatterPlot` — value vs. ability, age vs. potential
  - `BarChart` — league comparison, regional stats
  - `RadarChart` — player attribute profiles (reuse for F11)
  - `TrendLine` — player development trajectories over seasons
  - `HeatMap` — scouting coverage by country/region

**Modify `AnalyticsScreen.tsx`** (377 lines):
- Replace text-heavy display with visualization panels:
  - "Player Market" scatter: transfer value (y) vs current ability (x), colored by position
  - "Regional Coverage" heat map: darker = more scouts/observations in region
  - "Development Tracker" trend lines: selected players' CA trajectory over seasons
  - "League Comparison" bars: average player CA by league
  - "Anomaly Spotlight" highlighted dots on scatter for flagged players

**New file: `src/engine/data/visualizationData.ts`** (~200 lines)
- `generateScatterData(players, filter)` — prepare scatter plot data
- `generateCoverageHeatMap(observations, countries)` — coverage intensity
- `generateDevelopmentTrends(players, seasons)` — CA trajectories
- `generateLeagueComparison(players, leagues)` — league-level stats

### Checklist
- [x] Create `src/components/game/DataVisualization.tsx` with CSS-only chart components
- [x] Implement `ScatterPlot` component
- [x] Implement `BarChart` component
- [x] Implement `RadarChart` component (reusable for F11)
- [x] Implement `TrendLine` component
- [x] Implement `HeatMap` component
- [x] Create `src/engine/data/visualizationData.ts` with data preparation functions
- [x] Update `AnalyticsScreen.tsx` to use visualization components
- [x] Wire scatter plot for player market view
- [x] Wire heat map for regional coverage
- [x] Wire trend lines for player development tracking
- [x] Wire league comparison bars
- [x] `npm run build` passes

---

## Orchestration Protocol

### Agent Communication
Each agent must:
1. Read this document before starting work
2. Mark checklist items `[x]` as they complete them
3. Note any blockers with `⚠️ BLOCKED:` inline
4. Run `npm run build` at the end of each phase
5. Not modify files outside their feature scope without noting it

### Conflict Resolution
- **`types.ts` conflicts**: Agents add types at the END of the file in a clearly labeled section
- **`gameStore.ts` conflicts**: Each agent adds actions in a new clearly labeled section
- **`gameLoop.ts` conflicts**: Each agent adds processing calls as new lines in `processWeeklyTick`
- **Migration conflicts**: Each agent creates its own migration function named `migrate_F{N}(state)`

### Build Verification
After each wave completes:
1. `npm run build` must pass with zero new errors
2. All checklist items for the wave marked `[x]`
3. Blockers resolved or documented

### Progress Tracking
Update this file with completion status:
- Wave 1: [ ] Complete
- Wave 2: [ ] Complete
- Wave 3: [ ] Complete
- Full integration test: [ ] Complete
